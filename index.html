<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.12.0/dist/tf.min.js"></script>

<html>

<body>

<label for="avatar">Choose an image to apply styles to:</label>
<p/>

<input type="file"
       id="changeImage" name="changeImage"
       accept="image/png, image/jpeg" imgid="image" >   
<p/>
	   	   
<canvas id="image" url="/image.jpeg" width="348" height="348"/>
<p/>

<label for="avatar">Choose the style image:</label>
<p/>

<input type="file"
       id="changeStyleImage" name="changeImage"
       accept="image/png, image/jpeg" imgid="styleImage" >
	
<p/>	
<canvas id="styleImage"  url="/style_transfer_image.jpeg"  width="256" height="256"/>

<p/>
<button type="button" name="doStyleTransfer" onclick="doStyleTransfer()">Apply Style Transfer</button>
<p/>
<canvas id="stylizedImage" width="500" height="500"/>

</body>
</html>


<script>
window.addEventListener('load', initStyleTransfer());

let changeImage = function (evt) {
    var tgt = evt.target || window.event.srcElement,
        files = tgt.files;

    // FileReader support
    if (FileReader && files && files.length) {
        var fr = new FileReader();
        fr.onload = function () {
			let targetCanvas = document.getElementById(evt.target.getAttribute("imgid"));
			resizeAndSquareImage(fr.result, targetCanvas);
         
        }
        fr.readAsDataURL(files[0]);
		
		//=doStyleTransfer();
    }

    // Not supported
    else {
        // fallback -- perhaps submit the input to an iframe and temporarily store
        // them on the server until the user's session ends.
    }
}
var fastStyleTransferModel;

document.getElementById("changeImage").onchange = changeImage;
document.getElementById("changeStyleImage").onchange = changeImage;

async function initStyleTransfer() {
	let imageCanvas = document.getElementById("image");
	let styleImageCanvas = document.getElementById("styleImage");
	
	let imageUrl = imageCanvas.getAttribute("url");
	let imageStyleUrl = styleImageCanvas.getAttribute("url");
	await resizeAndSquareImage(imageUrl, imageCanvas);
	await resizeAndSquareImage(imageStyleUrl, styleImageCanvas);

}

async function loadModel() {
	return tf.loadGraphModel('/style_transfer_tfjs/model.json');
}

async function doStyleTransfer() {
	console.log("doStyleTransfer called");
	// load fast style transfer model only per page load
	if (!fastStyleTransferModel) {
		fastStyleTransferModel = await loadModel();
	}
	// get image to apply style to
	const image = document.getElementById("image");
	const styleImage = document.getElementById("styleImage");
	
	console.log("model=" + fastStyleTransferModel);
	
	let imageTensor = preprocess(image);
	let styleImageTensor = preprocess(styleImage);
	imageTensor = tf.pool(imageTensor, 3, 'avg', 'same', [1, 1], 1);
	styleImageTensor = tf.pool(styleImageTensor, 3, 'avg', 'same', [1, 1], 1);
		
    let result = fastStyleTransferModel.execute([styleImageTensor,imageTensor]);
	let canvas = document.getElementById("stylizedImage");
	
	tf.browser.toPixels( tf.squeeze(result), canvas);
} 

function preprocess(imageData) {
	let imageTensor = tf.browser.fromPixels(imageData);
    const offset = tf.scalar(255.0);
	const normalized = imageTensor.div(offset);
	const batched = normalized.expandDims(0);
	batched.print();
	console.log("dtype=" + batched.dtype);
	return batched;

}


function resizeAndSquareImage(imageUrl, targetCanvas) {
	// the desired aspect ratio of our output image (width / height)
	const outputImageAspectRatio = 1;

	// this image will hold our source image data
	const inputImage = new Image();
	console.log("resizeAndSquareImage called");
	// we want to wait for our image to load
	let result = inputImage.onload = () => {
		const imgSize = Math.min(inputImage.width, inputImage.height);
	    // The following two lines yield a central based cropping.
        // They can both be amended to be 0, if you wish it to be
        // a left based cropped image.
    	const left = (inputImage.width - imgSize) / 2;
    	const top = (inputImage.height - imgSize) / 2;
        //var left = 0; // If you wish left based cropping instead.
        //var top = 0; // If you wish left based cropping instead.
    	const ctx = targetCanvas.getContext("2d");
		ctx.drawImage(inputImage, left, top, imgSize, imgSize, 0, 0, targetCanvas.width, targetCanvas.height);
	  return targetCanvas;
	};
	inputImage.src = imageUrl;
	return result;
}


</script>
